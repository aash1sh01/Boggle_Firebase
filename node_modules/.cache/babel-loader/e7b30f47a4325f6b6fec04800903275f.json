{"ast":null,"code":"//Boggle Assignment 3: Improved after review\n//Submitted by Aashish Adhikari @02986124\n//added comments as per the suggestion\n//added more test cases\n//Initializing Trie class\nclass Trie {\n  constructor() {\n    this.head = {};\n    this.end = '#';\n  } //inserting a word inside trie for faster lookups\n\n\n  insert(word) {\n    var length = word.length;\n    if (length == 0) return;\n    var node = this.head;\n\n    for (var i = 0; i < length; i++) {\n      var char = word[i];\n\n      if (!(char in node)) {\n        node[char] = {};\n      }\n\n      node = node[char];\n    }\n\n    node[this.end] = word;\n  }\n\n} //this will search in our trie along the path of dfs\n\n\nexports.searchTrie = function () {\n  for (var i = 0; i < this.rows; i++) {\n    for (var j = 0; j < this.columns; j++) {\n      var visited = new Array(this.rows).fill(0).map(() => new Array(this.columns).fill(false));\n      this.dfs(this.trie.head, i, j, visited);\n    }\n  }\n}; //this function appends to our set all the found valid solutions and takes cares of edge cases like empty grid, empty dict\n\n\nexports.findAllSolutions = function (grid, dictionary) {\n  if (!grid.length) return [];\n  if (grid == null || dictionary == null) return [];\n  this.rows = grid.length;\n  this.columns = grid[0].length;\n\n  for (var i = 0; i < this.rows; i++) {\n    if (grid[i].length != this.columns) return [];\n  }\n\n  this.solns = new Set();\n  this.rows = grid.length;\n  this.columns = grid[0].length;\n  this.directions = [-1, 0, 1]; //directions to move in the grid\n\n  this.grid = grid; //initializing grid reference inside the function\n\n  this.trie = new Trie(); //initialising new trie object to add our words from dict\n\n  for (const word of dictionary) {\n    if (word.length > 2) this.trie.insert(word.toLowerCase());\n  }\n\n  this.searchTrie(); //searching the trie with words from dict\n\n  return Array.from(this.solns).sort(); //return valid words\n}; //checking to see if we go out of bounds of our grid\n\n\nexports.isSafeToVisit = function (i, j, visited) {\n  return i >= 0 && i < this.rows && j >= 0 && j < this.columns && !visited[i][j];\n}; //traversing adjacent tiles defined within our directions\n\n\nexports.traverseAdjacent = function (node, x, y, visited) {\n  if (this.trie.end in node) {\n    var word = node[this.trie.end];\n    this.solns.add(word);\n  }\n\n  for (var i of this.directions) {\n    for (var j of this.directions) {\n      var xi = x + i;\n      var yi = y + j;\n\n      if (this.isSafeToVisit(xi, yi, visited)) {\n        this.dfs(node, xi, yi, visited);\n      }\n    }\n  }\n}; //the originial dfs function that moves along the path and adds found words\n\n\nexports.dfs = function (node, x, y, visited) {\n  if (this.trie.end in node) {\n    var found = node[this.trie.end];\n    if (found.length > 2) this.solns.add(found);\n  }\n\n  if (visited[x][y]) return;\n  visited[x][y] = true;\n  var char = this.grid[x][y].toLowerCase();\n\n  if (char.length == 1) {\n    if (char in node) {\n      node = node[char];\n      this.traverseAdjacent(node, x, y, visited);\n    }\n  } else {\n    var temp = node;\n    var i = 0;\n    var search = true;\n\n    while (i < char.length && search) {\n      if (char[i] in temp && temp[char[i]] != '#') {\n        temp = temp[char[i]];\n        i++;\n      } else {\n        search = false;\n      }\n    }\n\n    if (search) {\n      this.traverseAdjacent(temp, x, y, visited);\n    }\n  }\n\n  visited[x][y] = false; //set visited to false after moving down a path\n};","map":{"version":3,"sources":["C:/Users/Lenovo/boggle/src/boggle_solver.js"],"names":["Trie","constructor","head","end","insert","word","length","node","i","char","exports","searchTrie","rows","j","columns","visited","Array","fill","map","dfs","trie","findAllSolutions","grid","dictionary","solns","Set","directions","toLowerCase","from","sort","isSafeToVisit","traverseAdjacent","x","y","add","xi","yi","found","temp","search"],"mappings":"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","sourcesContent":["//Boggle Assignment 3: Improved after review\n//Submitted by Aashish Adhikari @02986124\n\n//added comments as per the suggestion\n//added more test cases\n\n//Initializing Trie class\nclass Trie{\n  constructor(){\n    this.head = {}\n    this.end = '#'  \n  }\n\n//inserting a word inside trie for faster lookups\ninsert(word) {       \n  var length = word.length\n  if (length == 0) return;\n  var node = this.head\n  for (var i = 0; i < length; i++) {\n    var char = word[i]\n    if (!(char in node)) {\n      node[char] = {}\n    }\n    node = node[char]\n  }\n  node[this.end] = word\n}\n}  \n//this will search in our trie along the path of dfs\nexports.searchTrie = function() {\n  for (var i = 0; i < this.rows; i++) {\n    for (var j = 0; j < this.columns; j++) {\n      var visited = new Array(this.rows).fill(0).map(() => new Array(this.columns).fill(false))\n      this.dfs(this.trie.head, i, j, visited)\n    }\n  }\n}\n\n//this function appends to our set all the found valid solutions and takes cares of edge cases like empty grid, empty dict\n exports.findAllSolutions = function(grid, dictionary) {\n  if (!grid.length) return []\n  if (grid == null || dictionary == null) return []\n\n  this.rows = grid.length\n  this.columns = grid[0].length\n  for (var i = 0; i < this.rows; i++) {\n    if (grid[i].length != this.columns) return []\n  }\n\n  this.solns = new Set();\n\n  this.rows = grid.length\n  this.columns = grid[0].length\n  this.directions = [-1, 0, 1] //directions to move in the grid\n  this.grid = grid  //initializing grid reference inside the function\n\n  this.trie = new Trie();  //initialising new trie object to add our words from dict\n  for (const word of dictionary) {\n    if (word.length > 2) this.trie.insert(word.toLowerCase())\n  }\n\n  this.searchTrie(); //searching the trie with words from dict\n\n  return Array.from(this.solns).sort();  //return valid words\n}\n\n//checking to see if we go out of bounds of our grid\nexports.isSafeToVisit = function (i, j, visited){\n\treturn (i >= 0 && i < this.rows && j >= 0 && j < this.columns && !visited[i][j]); \n};\n\n\n//traversing adjacent tiles defined within our directions\nexports.traverseAdjacent = function(node, x, y, visited) {\n  if (this.trie.end in node) {\n    var word = node[this.trie.end]\n    this.solns.add(word)\n  }\n  for (var i of this.directions) {\n    for (var j of this.directions) {\n      var xi = x + i\n      var yi = y + j\n      if (this.isSafeToVisit(xi, yi, visited)) {\n        this.dfs(node, xi, yi, visited)\n      }\n    }\n  }\n}\n//the originial dfs function that moves along the path and adds found words\nexports.dfs = function(node, x, y, visited) {\n\n  if (this.trie.end in node) {\n    var found = node[this.trie.end]\n    if (found.length > 2) this.solns.add(found)\n  }\n\n  if (visited[x][y]) return\n  visited[x][y] = true\n\n  var char = this.grid[x][y].toLowerCase()\n  if (char.length == 1) {\n    if (char in node) {\n      node = node[char]\n      this.traverseAdjacent(node, x, y, visited)\n    }\n  } else {\n    var temp = node\n    var i = 0\n    var search = true\n    while (i < char.length && search) {\n      if (char[i] in temp && temp[char[i]] != '#') {\n        temp = temp[char[i]]\n        i++\n      } else {\n        search = false\n      }\n    }\n    if (search) {\n      this.traverseAdjacent(temp, x, y, visited)\n    }\n  }\n\n  visited[x][y] = false  //set visited to false after moving down a path\n}"]},"metadata":{},"sourceType":"module"}